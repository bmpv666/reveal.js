<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/black.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h1>Docker for Dummies</h1>
					<i style="font-style: italic; font-size: small">aka Docker workshop</i><br/>
					<i>by Bruno Valentim</i>
				</section>
				<section>
					<section data-markdown>
						<script type="text/template">
							## Index
							- What is Docker? <!-- .element: class="fragment" data-fragment-index="1" -->
								- Docker vs Regular VMs <!-- .element: class="fragment" data-fragment-index="2" -->
							- Understanding Docker, the basics <!-- .element: class="fragment" data-fragment-index="3" -->
								- Terminology <!-- .element: class="fragment" data-fragment-index="4" -->
								- Why use containers? <!-- .element: class="fragment" data-fragment-index="5" -->
								- Images vs Containers <!-- .element: class="fragment" data-fragment-index="6" -->
							- The Docker Hub <!-- .element: class="fragment" data-fragment-index="7" -->
						</script>
					</section>
					<section data-markdown>
						<script type="text/template">
							## Index (cont.)
							- Docker files and images <!-- .element: class="fragment" data-fragment-index="1" -->
								- How to create a Docker image <!-- .element: class="fragment" data-fragment-index="2" -->
								- How is a Docker Image created <!-- .element: class="fragment" data-fragment-index="3" -->
								- Multi-stage builds <!-- .element: class="fragment" data-fragment-index="4" -->
								- Best practices <!-- .element: class="fragment" data-fragment-index="5" -->
							- Docker Compose (vs Docker files) <!-- .element: class="fragment" data-fragment-index="6" -->
								- How to use an existing Docker image <!-- .element: class="fragment" data-fragment-index="7" -->
						</script>
					</section>
				</section>
				<section data-auto-animate>
					<h3>What is Docker?</h3>
				</section>
				<section data-auto-animate>
					<h3>What is Docker?</h3>
					Software platform that allows you to build, test, and deploy applications quickly.
				</section>
				<section data-auto-animate>
					<h3>What is Docker?</h3>
					Enables developers to automate the deployment and management of applications within software containers.
				</section>
				<section data-auto-animate>
					<h3>What is Docker?</h3>
					Provides a way to package applications and their dependencies into standardized units called Docker images.
				</section>
				<section data-transition="zoom-in fade-out">
					<h3>Docker ensures</h3>
					<ul>
						<li class="fragment fade-up">Portability</li>
						<li class="fragment fade-up">Consistency</li>
						<li class="fragment fade-up">Encapsulation</li>
						<li class="fragment fade-up">Scaling</li>
						<li class="fragment fade-up">Ecosystem</li>
					</ul>
					<aside class="notes">
						<p>Portability: images can be easily distributed and run on any system that has Docker installed, regardless of the underlying operating system or infrastructure.</p>
						<p>Consistency: developers can ensure that their applications run consistently across different environments, from development to testing and production.</p>
						<p>Encapsulation: the container is isolated from the outside world, just exposing some ports.</p>
						<p>Scaling: allows for easy scaling and orchestration, specially when combined with technologies like Kubernetes.</p>
						<p>Ecosystem: vast array of tools and services that complement the core functionality.</p>
					</aside>
				</section>
				<section>
					<section data-auto-animate>
						<h3>Docker vs Regular VMs</h3>
					</section>
					<section data-auto-animate>
						<h3>Docker vs Regular VMs</h3>
						<span style="vertical-align: middle">
							<img src="img/how-vm-works.png" style="display: block; margin-left: auto; margin-right: auto; width: 50%"/>
						</span>
						<aside class="notes">
							<p>VMs are an abstraction of physical hardware.</p>
							<p>Each VM includes a full copy of an operating system, the application, necessary binaries and libraries - taking up tens of GBs.</p>
							<p>VMs can also be slow to boot.</p>
						</aside>
					</section>
					<section data-auto-animate>
						<h3>Docker vs Regular VMs</h3>
						<img src="img/how-docker-works.png" style="display: block; margin-left: auto; margin-right: auto; width: 50%"/>
						<aside class="notes">
							<p>Docker is an abstraction of the application layer.</p>
							<p>Containers are isolated from each other and from the host - but they all share the same kernel.</p>
							<p>Containers can be created and destroyed in seconds.</p>
						</aside>
					</section>
				</section>
				<section>
					<section data-transition="zoom-in fade-out">
						<h3>Terminology</h3>
						<ul>
							<li class="fragment fade-up">Docker Image</li>
							<li class="fragment fade-up">Docker Container</li>
							<li class="fragment fade-up">Docker Daemon</li>
							<li class="fragment fade-up">Docker Client</li>
							<li class="fragment fade-up">Docker Hub</li>
						</ul>
					</section>
					<section>
						<h2>Docker Image</h2>
						<p>
							A Docker image is a read-only template that contains a set of instructions for creating a container that can run on the Docker platform.
						</p>
					</section>
					<section>
						<h2>Docker Container</h2>
						<p>
							A Docker container is a runnable instance of an image. You can create, start, stop, move, or delete a container using the Docker API or CLI.
						</p>
					</section>
					<section>
						<h2>Docker Daemon</h2>
						<p>
							The Docker daemon (dockerd) listens for Docker API requests and manages Docker objects such as images, containers, networks, and volumes.
						</p>
					</section>
					<section>
						<h2>Docker Client</h2>
						<p>
							The Docker client (docker) is the primary way that many Docker users interact with Docker. When you use commands such as docker run, the client sends these commands to dockerd, which carries them out.
						</p>
					</section>
					<section>
						<h2>Docker Hub</h2>
						<p>
							Docker Hub is a cloud-based registry service which allows you to link to code repositories, build your images and test them, stores manually pushed images, and links to Docker Cloud so you can deploy images to your hosts.
						</p>
					</section>
				</section>
				<section>
					<h3>Why use containers?</h3>
					<ul>
						<li class="fragment fade-up">Lightweight</li>
						<li class="fragment fade-up">Portable</li>
						<li class="fragment fade-up">Self-sufficient</li>
						<li class="fragment fade-up">Scalable</li>
						<li class="fragment fade-up">Secure</li>
					</ul>
					<aside class="notes">
						<p>Lightweight: containers share the same kernel, so they don't need to include a full OS.</p>
						<p>Portable: containers can run on any system that has Docker installed.</p>
						<p>Self-sufficient: containers include all the dependencies they need to run.</p>
						<p>Scalable: containers can be easily scaled and orchestrated.</p>
						<p>Secure: containers are isolated from each other and from the host.</p>
					</aside>
				</section>
				<section>
					<h3>Images vs Containers</h3>
					<ul>
						<li class="fragment fade-up">Images are read-only</li>
						<li class="fragment fade-up">Containers are writable</li>
						<li class="fragment fade-up">Containers are created from images</li>
						<li class="fragment fade-up">Containers are meant to be temporary</li>
					</ul>
					<aside class="notes">
						<p>Images are read-only templates that contain a set of instructions for creating a container that can run on the Docker platform.</p>
						<p>Containers are writable, and they are created from images.</p>
						<p>Containers are meant to be temporary, and they can be created and destroyed in seconds.</p>
					</aside>
				</section>
				<section>
					<h3>The Docker Hub</h3>
					<ul>
						<li class="fragment fade-up">Official images</li>
						<li class="fragment fade-up">Community images</li>
						<li class="fragment fade-up">Private images</li>
					</ul>
					<aside class="notes">
						<p>Official images are Docker images curated and optimized by the Docker community and Docker, Inc.</p>
						<p>Community images are Docker images created and shared by Docker community members.</p>
						<p>Private images are Docker images that you or your organization create and store in your own private registry.</p>
					</aside>
				</section>
				<section>
					<section data-auto-animate>
						<h3>Docker files and images</h3>
					</section>
					<section data-auto-animate>
						<h3>Docker files and images</h3>
						<h4>How to build an image</h4>
					</section>
					<section data-auto-animate>
						<h4>How to build an image</h4>
						<p>1. Create a Dockerfile</p>
					</section>
					<section data-auto-animate>
						<h4 data-id="code-title">How to build an image</h4>
						<p data-id="code-title">1. Create a Dockerfile</p>
						<pre data-id="code-animation">
							<code class="hljs" data-trim data-line-numbers="*|1|3,4|6|8|10,11|13">
								FROM eclipse-temurin:latest

								ENV APP_DIR=/app
								ENV JVM_OPTS="-XX:InitialRAMPercentage=75.0 -XX:MaxRAMPercentage=75.0"

								ARG JAR_FILE

								WORKDIR ${APP_DIR}

								COPY --chown=java:users target/${JAR_FILE} ./app.jar
								COPY --chown=java:users ./keystore.jks ./keystore.jks

								ENTRYPOINT exec java $JAVA_OPTIONS $JVM_OPTS -jar ./app.jar
							</code>
						</pre>
						<p><a href="https://docs.docker.com/engine/reference/builder/#dockerfile-reference">Docker file reference docs</a></p>
						<aside class="notes">
							<p>Need to specify a base image.</p>
							<p>First line must be FROM (except for ARG)</p>
							<p>FROM can be followed by a tag, which is a version of the image</p>
							<p>ENV declares environment variables that'll be accessible inside the container</p>
							<p>ARG declares an external argument that should be provided at build time</p>
							<p>WORKDIR sets (and creates if it does not exist) the working directory inside the container</p>
							<p>COPY copies files from the host to the container</p>
							<p>ENTRYPOINT specifies the command that should be executed when the container is started</p>
						</aside>
					</section>
					<section data-auto-animate>
						<h4>How to build an image</h4>
						<p>2. Build the image</p>
					</section>
					<section data-auto-animate>
						<h4>How to build an image</h4>
						<p>2. Build the image</p>
						<pre>
							<code class="language-vim">
								$ docker build -t my-image .
							</code>
						</pre>
					</section>
					<section data-auto-animate>
						<h4>How to build an image</h4>
						<p>2. Build the image</p>
						<pre>
							<code class="language-vim">
								$ docker build -t name:tag .
							</code>
						</pre>
					</section>
					<section data-auto-animate>
						<h4>How to build an image</h4>
						<p>3. Run the container</p>
					</section>
					<section data-auto-animate>
						<h4>How to build an image</h4>
						<p>3. Run the container</p>
						<pre>
							<code class="language-vim">
								$ docker run my-image
							</code>
						</pre>
					</section>
				</section>
				<section>
					<section data-auto-animate>
						<h3>Docker files and images</h3>
					</section>
					<section data-auto-animate>
						<h3>Docker files and images</h3>
						<h4>How is a Docker Image created</h4>
					</section>
					<section data-auto-animate>
						<h4>How is a Docker Image created</h4>
						<p>A series of layers</p>
					</section>
					<section data-auto-animate>
						<h4>How is a Docker Image created</h4>
						<p>A series of layers</p>
						<p>Each instruction in the Dockerfile creates a new layer</p>
					</section>
					<section data-auto-animate>
						<h4>How is a Docker Image created</h4>
						<p>So, this...</p>
						<pre data-id="code-animation">
							<code class="hljs" data-trim>
								FROM eclipse-temurin:latest

								ENV APP_DIR=/app
								ENV JVM_OPTS="-XX:InitialRAMPercentage=75.0 -XX:MaxRAMPercentage=75.0"

								ARG JAR_FILE

								WORKDIR ${APP_DIR}

								COPY --chown=java:users target/${JAR_FILE} ./app.jar
								COPY --chown=java:users ./keystore.jks ./keystore.jks

								ENTRYPOINT exec java $JAVA_OPTIONS $JVM_OPTS -jar ./app.jar
							</code>
						</pre>
					</section>
					<section data-auto-animate>
						<h4>How is a Docker Image created</h4>
						<p>...becomes this</p>
						<img src="img/docker-layers.png" style="display: block; margin-left: auto; margin-right: auto; width: 50%"/>
					</section>
					<section data-auto-animate>
						<h4>How is a Docker Image created</h4>
						<p>...becomes this</p>
						<img src="img/docker-layers.png" style="display: block; margin-left: auto; margin-right: auto; width: 50%"/>
						<p>Each layer builds on top of the previous layers.</p>
					</section>
					<section data-auto-animate>
						<h4>How is a Docker Image created</h4>
						<p>Layers are cached...</p>
						<img src="img/docker-layers.png" style="display: block; margin-left: auto; margin-right: auto; width: 50%"/>
					</section>
					<section data-auto-animate>
						<h4>How is a Docker Image created</h4>
						<p>Layers are cached...</p>
						<img src="img/docker-layers-rebuild.png" style="display: block; margin-left: auto; margin-right: auto; width: 50%"/>
						<p>...so if you change a line in the Dockerfile, only the layers after that line will be rebuilt.</p>
					</section>
					<section data-auto-animate>
						<h4>How is a Docker Image created</h4>
						<p>And each running container...</p>
					</section>
					<section data-auto-animate>
						<h4>How is a Docker Image created</h4>
						<p>And each running container...</p>
						<img src="img/docker-layers-container.png" style="display: block; margin-left: auto; margin-right: auto; width: 50%"/>
						<p>...creates it's own layer.</p>
					</section>
					<section data-auto-animate>
						<h4>How is a Docker Image created</h4>
						<p>And each running container...</p>
						<img src="img/docker-layers-container.png" style="display: block; margin-left: auto; margin-right: auto; width: 50%"/>
						<p>...creates it's own layer.</p>
						<p>So, if you change a file inside the container, that change will only be visible in that container's layer.</p>
						<aside class="notes">
							<p>Instruction order can have an impact on how many layers docker has to rebuild if you change a previous instruction</p>
							<p>COPY instructions should be placed as late as possible</p>
						</aside>
					</section>
				</section>
				<section>
					<section data-auto-animate>
						<h3>Docker files and images</h3>
					</section>
					<section data-auto-animate>
						<h3>Docker files and images</h3>
						<h4>Multi-stage builds</h4>
					</section>
					<section data-auto-animate>
						<h4>Multi-stage builds</h4>
						<ul>
							<li>Allow to run build steps in parallel</li>
							<li>Reduce the size of the final image</li>
						</ul>
					</section>
					<section data-auto-animate>
						<h4>Multi-stage builds</h4>
						<pre>
							<code data-trim data-line-numbers="*|1,7,10,13">
								FROM golang:1.21-alpine AS base
								WORKDIR /src
								COPY go.mod go.sum .
								RUN go mod download
								COPY . .

								FROM base AS build-client
								RUN go build -o /bin/client ./cmd/client

								FROM base AS build-server
								RUN go build -o /bin/server ./cmd/server

								FROM scratch
								COPY --from=0 /bin/client /bin/server /bin/
								COPY --from=build-client /bin/client /bin/
								COPY --from=build-server /bin/server /bin/
								ENTRYPOINT [ "/bin/server" ]
							</code>
						</pre>
						<p style="font-size: small">Example from <a href="https://docs.docker.com/build/guide/multi-stage/">Docker Docs</a></p>
					</section>
					<section data-auto-animate>
						<h4>Multi-stage builds</h4>
						<p>You can parallelize the build</p>
						<img src="img/docker-build-parallelism.gif" style="display: block; margin-left: auto; margin-right: auto; width: 50%"/>
						<p style="font-size: small">Image from <a href="https://docs.docker.com/build/guide/multi-stage/">Docker Docs</a></p>
					</section>
				</section>
				<section>
					<section data-auto-animate>
						<h3>Docker files and images</h3>
					</section>
					<section data-auto-animate>
						<h3>Docker files and images</h3>
						<h4>Best practices</h4>
					</section>
					<section data-auto-animate>
						<h4>Best practices</h4>
						<ul>
							<li class="fragment fade-up">Use official images</li>
							<li class="fragment fade-up">Use multi-stage builds</li>
							<li class="fragment fade-up">Exclude .dockerignore</li>
							<li class="fragment fade-up">Create ephemeral containers</li>
							<li class="fragment fade-up">Don't install unnecessary packages</li>
							<li class="fragment fade-up">Decouple applications</li>
							<li class="fragment fade-up">Sort multi-line arguments</li>
							<li class="fragment fade-up">Leverage the Build Cache</li>
						</ul>
					</section>
					<section data-auto-animate>
						<h4>Best practices</h4>
						<h5>Use official images</h5>
						<p>Official images are curated and optimized by the Docker community and Docker, Inc.</p>
					</section>
					<section data-auto-animate>
						<h4>Best practices</h4>
						<h5>Use multi-stage builds</h5>
						<ul>
							<li>Let you reduce the size of your final image.</li>
							<li>Make sure that the resulting output only contains the files that's needed to run the application.</li>
							<li>Build more efficiently by executing build steps in parallel.</li>
						</ul>
					</section>
					<section data-auto-animate>
						<h4>Best practices</h4>
						<h5>Exclude .dockerignore</h5>
						<p>Files and directories specified in .dockerignore are excluded from the build context.</p>
					</section>
					<section data-auto-animate>
						<h4>Best practices</h4>
						<h5>Create ephemeral containers</h5>
						<p>Ephemeral means that the container can be stopped and destroyed, then rebuilt and replaced with an absolute minimum set up and configuration.</p>
					</section>
					<section data-auto-animate>
						<h4>Best practices</h4>
						<h5>Don't install unnecessary packages</h5>
						<p>Only install the packages that are required for the application to run.</p>
					</section>
					<section data-auto-animate>
						<h4>Best practices</h4>
						<h5>Decouple applications</h5>
						<p>Each container should have a single concern.</p>
						<aside class="notes">
							<p>Easier to scale horizontally and reuse containers</p>
							<p>For example, a web application stack might consist of three separate containers, each with its own unique image, that are connected and work together: one container for the web application, one for the application's database, and another for the database admin interface.</p>
						</aside>
					</section>
					<section data-auto-animate>
						<h4>Best practices</h4>
						<h5>Sort multi-line arguments</h5>
						<pre>
							<code class="hljs" data-trim>
								RUN apt-get update && apt-get install -y \
								  bzr \
								  cvs \
								  git \
								  mercurial \
								  subversion \
								  && rm -rf /var/lib/apt/lists/*
							</code>
						</pre>
						<aside class="notes">
							<p>Alphabetical order makes it easier to add new entries, and avoids duplication of parameters</p>
						</aside>
					</section>
					<section data-auto-animate>
						<h4>Best practices</h4>
						<h5>Leverage the Build Cache</h5>
						<p>Perform instructions that are less likely to change at the top of the Dockerfile.</p>
						<p>For example, RUN instructions that install packages are less likely to change than COPY or ADD instructions.</p>
						<aside class="notes">
							<p>Instructions are cached and only rebuilt if they change</p>
							<p>So, if you change a line in the Dockerfile, only the layers after that line will be rebuilt.</p>
							<p>Instruction order can have an impact on how many layers docker has to rebuild if you change a previous instruction</p>
							<p>COPY instructions should be placed as late as possible</p>
						</aside>
					</section>
				</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,
				controls: true,
				progress: true,
				history: true,
				center: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
